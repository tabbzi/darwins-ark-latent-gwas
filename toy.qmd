---
title: "Decoding canine behavior: Multivariate genomic analysis of latent phenotypes (toy example"
author: "Kathleen Morrill Pirovich"
date: 2023-09-10
date_format: iso
format: html
editor: visual
---

## Prepare data

### Load libraries

```{r}
#| echo: false
library(tidyverse)
library(data.table)
library(BEDMatrix)
library(genio)
library(irlba)
library(lavaan)
library(moments)
library(factoextra)
library(psych)
library(umap)
library(corrplot)
library(PerformanceAnalytics)
library(GenomicRanges)
library(OrganismDbi)
library(BSgenome.Cfamiliaris.UCSC.canFam3)
library(TxDb.Cfamiliaris.UCSC.canFam3.refGene)
library(org.Cf.eg.db)
library(karyoploteR)
library(ggrepel)
library(ggpubr)
library(ggtext)
library(ggfittext)
library(plotly)
library(hexbin)
library(patchwork)
library(lme4)
library(broom.mixed)
library(showtext)
library(dplyr)

pal = c("#EEE1CB", "#5FA29B", "#2B555D", "#FEAE03", "#E06545", "#769762", "#B95E79")
bsg = BSgenome.Cfamiliaris.UCSC.canFam3
txd = TxDb.Cfamiliaris.UCSC.canFam3.refGene
org = org.Cf.eg.db

font_add_google("Bodoni Moda", family="bodoni")
font_add_google("Roboto Condensed", family="roboto")
showtext_auto()

out = "2024-01-23"
```

### Load data set

```{r}
# Read in z-score matrix file
mat = read_csv("toy/toy_mat.csv.gz")
mat_row = mat$rowname
mat = mat %>% select(-rowname)
mat = as.matrix(mat)
rownames(mat) = mat_row

# Read in phenotypes table
phe = read_tsv("toy/toy_phe.tsv.gz")

# Read in variants table
var = read_tsv("toy/toy_var.tsv.gz")

# Read in PLINK data set
gen = BEDMatrix("dat/DarwinsArk_gp-0.70_biallelic-snps_maf-0.001_geno-0.05_hwe-1e-20-midp-keep-fewhet_N-3465_ld-100-by-50-r2-0.8.bed")

# Read in genetic relationship matrix (GRM)
grm = read_grm("dat/DarwinsArk_gp-0.70_biallelic-snps_maf-0.001_geno-0.05_hwe-1e-20-midp-keep-fewhet_N-3465")

# Read in survey data
dog = read_csv("data_release/dat/DarwinsArk_20221120_dogs.csv")
que = read_csv("data_release/dat/DarwinsArk_20221120_questions.csv")
ans = read_csv("data_release/dat/DarwinsArk_20221120_answers.csv")
```

### Annotate gene ranges and annotations

```{r}
gene_range_threshold = 250000

vgr =  GRanges(
  seqnames = paste("chr", var$chr, sep = ""),
  ranges = IRanges(start = var$pos, end = var$pos),
  snp = var$snp,
  ref = var$ref,
  alt = var$alt, 
  seqinfo = seqinfo(bsg)
)

cds = cdsBy(txd, by = "gene")

ovl = findOverlaps(vgr, cds + gene_range_threshold)

var_ann = var[queryHits(ovl),]
var_ann$gene_id = names(cds[subjectHits(ovl)])
var_ann$gene_symbol = mapIds(org,
                             keys = var_ann$gene_id, 
                             column = "SYMBOL", 
                             keytype = "ENTREZID") 

var_ann = var_ann %>%
  group_by(snp) %>%
  summarise(genes = paste(gene_symbol, collapse = ","))

var = var %>% merge(var_ann, by = "snp", all.x = T)
```

### Save and load RData

```{r}
save.image("toy.RData")
```

```{r}
load("toy.RData")
```

## Summary statistics

### Calculate genetic covariance matrix adjusted by LD score

```{r}
# Generate covariance matrix
cov_mat = (t(mat) * sqrt(var$lds)) %*% t(t(mat) * sqrt(var$lds))

# Add row and column names
rownames(cov_mat) = phe$phe
colnames(cov_mat) = phe$phe

# Hierarchical clustering
cov_mat = cov_mat[hclust(dist(cov_mat))$order,hclust(dist(cov_mat))$order]

# Convert covariance to correlation matrix
cor_mat = cov2cor(cov_mat)

# Convert to data frame and set factors
cor_mat_dt = as.data.frame(as.table(cor_mat))
cor_mat_dt$Var1 = factor(cor_mat_dt$Var1, levels = rownames(cor_mat)[hclust(dist(cov_mat))$order])
cor_mat_dt$Var2 = factor(cor_mat_dt$Var2, levels = rev(rownames(cor_mat)[hclust(dist(cov_mat))$order]))

# Get non-redundant long form
cor_mat_dt_unique = data.frame(row = rownames(cor_mat)[which(upper.tri(cor_mat, diag = TRUE), arr.ind = TRUE)[, 1]], col = colnames(cor_mat)[which(upper.tri(cor_mat, diag = TRUE), arr.ind = TRUE)[, 2]], value = cor_mat[upper.tri(cor_mat, diag = TRUE)])
```

### Plot genetic correlations across all phenotypes

```{r}
p.cor = cor_mat_dt %>%
  rename(`genetic correlation` = Freq) %>%
  ggplot(aes(x = str_wrap(Var1, width=40), 
             y = str_wrap(Var2, width=40))) +
  geom_tile(color = NA, aes(fill = `genetic correlation`)) +
  scale_size_continuous(range = c(1, 10)) +
  scale_fill_gradient(low = pal[4], high = pal[2]) +
  theme_pubr() +
  theme(axis.title = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_text(color = pal[3], size = 4),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        plot.background = element_blank(),
        text = element_text(color = pal[3]),
        axis.ticks = element_line(color = pal[3]),
        plot.margin = margin(1, 1, 1, 1, "cm")) 
ggsave(filename = "toy/p.gen-cor.pdf",
       plot = p.cor,
       device = "pdf",
       units = "in",
       height = 8.5,
       width = 5)

p.cor = cor_mat_dt %>%
  rename(`genetic correlation` = Freq) %>%
  ggplot(aes(x = str_wrap(Var1, width=40), 
             y = str_wrap(Var2, width=40))) +
  geom_tile(color = NA, aes(fill = `genetic correlation`)) +
  scale_size_continuous(range = c(1, 10)) +
  scale_fill_viridis_c(direction = 1) +
  theme_pubr() +
  theme(legend.position="none",
        axis.title = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.line = element_line(color = pal[3]),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        plot.background = element_blank(),
        text = element_text(color = pal[3]),
        axis.ticks = element_line(color = pal[3])) 
ggsave(filename = "toy/p.gen-cor.png",
       plot = p.cor,
       device = "png",
       units = "px",
       height = 900,
       width = 1700)
```

### View and save widget of genetic correlation interactive plot

```{r}
fig = plot_ly(x = colnames(cor_mat), 
              y = rownames(cor_mat), 
              z = cor_mat, 
              type = "heatmap") %>%
  layout(title = "LD score regressed genetic correlation matrix",
         xaxis = list(showticklabels = FALSE, showgrid = FALSE, zeroline = FALSE))
fig
htmlwidgets::saveWidget(fig, "toy/interactive_heatmap.html")

pheatmap::pheatmap(cor_mat,
                   show_rownames = F, 
                   show_colnames = F, 
                   color = viridis::viridis(256),
                   cluster_rows = F, 
                   cluster_cols = F, 
                   legend = F,
                   scale = "none",
                   filename = "toy/p.gen-cor.pheatmap.png",
                   width = 9.5,
                   height = 4.5)
```

## Prune data set

Genomic associations for morphology traits are very strong, more so than behavior associations. Let's remove most of these:

```{r}
phe = phe %>% filter(phe_code %like% "bq." | 
                       phe_code == "age" | 
                       phe_code %in% c("mq.121"))
mat = mat[,phe$idx]
```

# Coding with R-ubber Duckies!

## Pseudo-code

```{r}

```

## Attempt

```{r}

```

## Sanity Check

```{r}

```

## Document

```{r}

```

# Work-in-progress code

## Principal component analysis

### Perform principal component analysis

```{r}
pca_res = FactoMineR::PCA(t(mat), 
                          scale.unit = TRUE, 
                          ncp = 10, 
                          graph = FALSE)
```

### Explore results

```{r}
bind_cols(phe$phe, pca_res$ind$contrib %>% as_tibble()) %>% arrange(-Dim.1)
```

```{r}
bind_cols(snp= var$snp, 
          genes= var$genes, 
          pca_res$var$contrib %>% as_tibble()) %>% 
  arrange(-Dim.6)
```

```{r}
# Pull those genes!
bind_cols(snp= var$snp, 
          genes= var$genes, 
          pca_res$var$contrib %>% as_tibble()) %>% 
  arrange(-Dim.5) %>%
  head(n=20) %>%
  pull(genes) %>%
  unique() %>%
  paste(collapse = ",")
```

```{r}
bind_cols(phe= phe$phe, 
          pca_res$ind$contrib %>% as_tibble()) %>% 
  arrange(-Dim.6)
```

```{r}
# Which trait GWAS had high effects for top SNP in PCA?
this_snp = "24:32752934:G:C"
mat[(var %>% filter(snp == this_snp) %>% pull(idx)),] %>% as_tibble() %>% 
  mutate(phe = phe$phe) %>%
  arrange(-abs(value))
```

### Plot relative variance explained by each PC

```{r}
p.scree = as_tibble(pca_res$eig) %>%
  mutate(idx = row_number()) %>%
  filter(idx < 25) %>%
  ggplot(aes(x = idx, 
             y = eigenvalue)) +
  geom_line(color = pal[3]) +
  geom_point(color = pal[3], 
             shape = 21, 
             fill = pal[2], 
             stroke = 1, 
             size = 3) +
  xlab("component index") +
  ylab("proportion of variance explained") +
  theme_pubr() +
  theme(legend.position = "none",
        panel.background = element_blank(),
        plot.background = element_blank(),
        text = element_text(color = pal[3], size = 32),
        axis.line = element_line(color = pal[3]),
        axis.title = element_text(color = pal[3], size = 32),
        axis.text = element_text(color = pal[3], size = 32),
        axis.ticks = element_line(color = pal[3])) 

ggsave(filename = paste("toy/plot.","pca",".scree-plot.png", sep =" "),
       plot = p.scree,
       device = "png",
       bg = "transparent", 
       width = 6,
       height = 5,
       units = "in")

p.scree
```

### Visualize components by traits captured

```{r}
p.pca_ind = fviz_pca_ind(pca_res, col.var="contrib") +
  theme_minimal()

p.pca_ind
```

### Summarize by trait

```{r}

```

### Summarize by variant

```{r}

```

## Structural value decomposition

### Run truncated singular value decomposition (tSVD) using irlba package

```{r}
# Run truncated singular value decomposition on n_var columns x n_phe rows (transpose)
n_svd = 10
svd_res = irlba(t(mat), nv = n_svd)

# Save tSVD results to file
write_csv(as.data.frame(svd_res$d), "toy/d_values.csv")
write_csv(as.data.frame(svd_res$u), "toy/u_values.csv")
write_csv(as.data.frame(svd_res$v), "toy/v_values.csv")
```

### Plot relative variance explained by each latent component

```{r}
p.scree = data.frame(S = svd_res$d,
                     index = 1:length(svd_res$d)) %>%
  mutate(prop_variance = S^2 / sum(S^2)) %>%
  ggplot(aes(x = index, 
             y = prop_variance)) +
  geom_line(color = pal[3]) +
  geom_point(color = pal[3], 
             shape = 21, 
             fill = pal[2], 
             stroke = 1, 
             size = 3) +
  xlab("component index") +
  ylab("proportion of variance explained") +
  theme_pubr() +
  theme(legend.position = "none",
        panel.background = element_blank(),
        plot.background = element_blank(),
        text = element_text(color = pal[3], size = 32),
        axis.line = element_line(color = pal[3]),
        axis.title = element_text(color = pal[3], size = 32),
        axis.text = element_text(color = pal[3], size = 32),
        axis.ticks = element_line(color = pal[3])) 
ggsave(filename = paste("toy/plot.",out,".scree-plot.png", sep =" "),
       plot = p.scree,
       device = "png",
       bg = "transparent", 
       width = 6,
       height = 5,
       units = "in")
p.scree
```

### Scoring phenotypes and variants: factor, contribution, and squared cosine scores

Here, we generate factor scores that are equivalent to principal components in PCA, and measure how phenotypes and variants contribute to specific latent components. We also calculate two complementary metrics: contribution scores and squared cosine scores. These metrics quantify the importance of each phenotype, variant, and component. Note that these metrics may not align perfectly; for example, a phenotype's key component according to its squared cosine score may differ when evaluated by its contribution score. This is because the two metrics normalize different aspects of the data: one along rows (phenotypes and variants) and the other along columns (latent components).

```{r}
# Calculate factor scores -- equivalent to PCA -- for phenotypes and variants
fac_phe = svd_res$u %*% diag(svd_res$d)
fac_var = svd_res$v %*% diag(svd_res$d)

# Calculate contribution scores for phenotypes and variants
con_phe = matrix(0, nrow(svd_res$u), ncol(svd_res$u))
con_var = matrix(0, nrow(svd_res$v), ncol(svd_res$v))

for (k in 1:ncol(svd_res$u)) {
  con_phe[, k] = svd_res$u[, k]^2
  con_phe[, k] = con_phe[, k] / sum(con_phe[, k])

  con_var[, k] = svd_res$v[, k]^2
  con_var[, k] = con_var[, k] / sum(con_var[, k])
}

# Calculate squared cosine scores for phenotypes
cos_phe = sweep(fac_phe^2, 1, rowSums(fac_phe^2), FUN = "/")

# Run squared cosine scoring for variants in batches
cos_var = matrix(0, nrow = nrow(fac_var), ncol = ncol(fac_var))
batch_size = 10000

# Loop through batches
for (i in seq(1, nrow(fac_var), by = batch_size)) {
  idx = i:min((i + batch_size - 1), nrow(fac_var))
  batch = fac_var[idx, , drop=FALSE]
  rs = rowSums(batch^2)
  cos_var[idx, ] = sweep(batch^2, 1, rs, FUN = "/")
}

# Check output row sums ~ 1
# rowSums(cos_phe)
# rowSums(cos_var)
```

#### Summarize scores across variants

```{r}
svd_var_scores = bind_cols((var[rep(seq_len(nrow(var)), times = ncol(fac_var)), , drop = FALSE]),
                           (as.data.frame(fac_var) %>% 
  pivot_longer(everything(), names_to = "svd", values_to = "fac") %>%
  mutate(svd = as.integer(gsub("V", "", svd)))),
                       (as.data.frame(con_var) %>% 
  pivot_longer(everything(), names_to = "svd", values_to = "con") %>%
  select(-svd)),
                       (as.data.frame(cos_var) %>% 
  pivot_longer(everything(), names_to = "svd", values_to = "cos") %>%
  select(-svd)))
```

```{r}
svd_var_scores %>%
  filter(svd == 4) %>%
  arrange(-abs(con))
```

#### Summarize scores across phenotypes

```{r}
svd_phe_scores = bind_cols(((phe)[rep(seq_len(nrow(phe)), times = ncol(fac_phe)), , drop = FALSE]),
                           (as.data.frame(fac_phe) %>% 
  pivot_longer(everything(), names_to = "svd", values_to = "fac") %>%
  mutate(svd = as.integer(gsub("V", "", svd)))),
                       (as.data.frame(con_phe) %>% 
  pivot_longer(everything(), names_to = "svd", values_to = "con") %>%
  select(-svd)),
                       (as.data.frame(cos_phe) %>% 
  pivot_longer(everything(), names_to = "svd", values_to = "cos") %>%
  select(-svd)))

```

```{r}
svd_phe_scores %>%
  filter(svd == 4) %>%
  arrange(-abs(con))
```

#### Plot phenotype scores

```{r}
i = 1

svd_phe_scores %>% 
  filter(svd==i) %>%
  filter(abs(fac) >= quantile(abs(fac), 0.95),
         abs(con) >= quantile(abs(con), 0.95),
         abs(cos) >= quantile(abs(cos), 0.95))

svd_phe_scores %>%
  filter(svd == i) %>%
  plot_ly(x = ~fac, y = ~con, z = ~cos,
          type = 'scatter3d', mode = 'markers',
          marker = list(size = 2, opacity = 0.6),
          text = ~ifelse(is.na(short), as.character(phe), as.character(short))) %>%
  add_trace(hoverinfo = "text") %>%
  layout(scene = list(xaxis = list(title = 'Fac'),
                      yaxis = list(title = 'Con'),
                      zaxis = list(title = 'Cos')))

```

#### Plot variant scores

```{r}
i = 1

svd_var_scores %>% 
  filter(svd==i) %>%
  filter(abs(fac) >= quantile(abs(fac), 0.95),
         abs(con) >= quantile(abs(con), 0.95),
         abs(cos) >= quantile(abs(cos), 0.95)) %>%
  plot_ly(x = ~fac, y = ~con, z = ~cos,
          type = 'scatter3d', mode = 'markers',
          marker = list(size = 2, opacity = 0.6),
          text = ~snp) %>%
  add_trace(hoverinfo = "text") %>%
  layout(scene = list(xaxis = list(title = 'Fac'),
                      yaxis = list(title = 'Con'),
                      zaxis = list(title = 'Cos')))
```

#### Plot contribution scores vs squared cosine scores

```{r}
i = 1
svd_var_scores %>%
  filter(svd == i) %>%
  ggplot(aes(x = cos,
             y = con)) +
  geom_point(shape = 1,
             color = pal[2]) +
  labs(x = "squared cosine score",
       y = "contribution score") +
  theme_pubr() +
  theme(legend.position = "none",
        panel.background = element_blank(),
        plot.background = element_blank(),
        text = element_text(color = pal[3], size = 32),
        axis.line = element_line(color = pal[3]),
        axis.title = element_text(color = pal[3], size = 32),
        axis.text = element_text(color = pal[3], size = 32),
        axis.ticks = element_line(color = pal[3])) 
```

## Annotate genes within range of variants

### Define genomic ranges and annotations

```{r}
gene_range_threshold = 250000

vgr =  GRanges(
  seqnames = paste("chr", var$chr, sep = ""),
  ranges = IRanges(start = var$pos, end = var$pos),
  snp = var$snp,
  ref = var$ref,
  alt = var$alt, 
  seqinfo = seqinfo(bsg)
)

cds = cdsBy(txd, by = "gene")

ovl = findOverlaps(vgr, cds + gene_range_threshold)

var_ann = var[queryHits(ovl),]
var_ann$gene_id = names(cds[subjectHits(ovl)])
var_ann$gene_symbol = mapIds(org,
                             keys = var_ann$gene_id, 
                             column = "SYMBOL", 
                             keytype = "ENTREZID") 

var_ann = var_ann %>%
  group_by(snp) %>%
  summarise(genes = paste(gene_symbol, collapse = ","))
```

### Merge onto variant scores

```{r}
svd_var_scores = svd_var_scores %>%
  merge(var_ann, 
        by = "snp", 
        all.x = T) %>%
  arrange(svd,1/(con*cos))
```

## Meta-analysis of GWAS

### Random-effects meta-analysis of GWA z-scores

In this analysis, we conduct a random-effects meta-analysis using genome-wide association z-scores. Each phenotype column in the GWA z-score matrix (variant x phenotype) is element-wise multiplied by its respective contribution score vector. Similarly, the same operation is performed for each variant row using the variant's contribution score. Unlike fixed-effects models, we additionally estimate between-study (or between-phenotype) variance, often denoted as tau-squared, to account for heterogeneity across phenotypes. We then calculate new weights that incorporate both within- and between-study variances. The sum of each row, weighted by these new random-effects weights, provides the meta z-score for each variant. Meta p-values are subsequently derived from the absolute meta z-scores and are corrected for multiple testing using the Benjamini & Hochberg false discovery rate (FDR) method. This approach allows for a more nuanced incorporation of each tSVD component's influence in the meta-analysis.

```{r}
# fixed
svd_gwa_rem = data.frame()

# For each component i
for (i in 1:n_svd) {
  # Initial placeholders for random-effects meta-z and meta-var
  met_z = numeric(n_var)
  met_var = numeric(n_var)
  
  # Loop through each SNP
  for (j in 1:n_var) {
    # Extract z-scores for SNP j across all phenotypes
    z_scores = mat[j, (colnames(mat) %in% idx_phe)]
    
    # Calculate within-study variances
    # within_var = rep(1, n_phe) # assuming Var(z) = 1
    within_var =
    
    # DerSimonian-Laird estimator for tau-squared
    tau2 = max(0, (sum(con_phe[, i] * con_var[j, i] * z_scores^2) - n_phe) / (sum(con_phe[, i] * con_var[j, i]) - n_phe))
    
    # Calculate random-effects weights
    rand_weights = con_phe[, i] * con_var[j, i] / (within_var + tau2)
    
    # Calculate random-effects meta-z and meta-variance
    met_z[j] = sum(rand_weights * z_scores) / sqrt(sum(rand_weights^2))
    met_var[j] = 1 / sum(rand_weights^2)
  }

    tmp_df = data.frame(
    svd = rep(i, length(met_z)),
    chr = var$chr,
    pos = var$pos,
    ref = var$ref,
    alt = var$alt,
    snp = var$snp,
    svd_var_cos = cos_var[, i],
    svd_var_con = con_var[, i],
    met_z = met_z,
    met_var = met_var
  )
  
  svd_gwa_rem = rbind(svd_gwa_rem, tmp_df)
}

svd_gwa_rem = svd_gwa_rem %>% 
  group_by(svd) %>% 
  mutate(met_p = 2 * (1 - pnorm(abs(met_z)))) %>%
  mutate(met_p_cor_fdr = p.adjust(met_p, method = "fdr"))

```

#### Plot distributions of meta z-scores and variances

```{r}
svd_gwa_rem %>%
  ggplot(aes(x = met_z)) +
  geom_density() +
  facet_wrap(~svd)

svd_gwa_rem %>%
  ggplot(aes(x = met_var)) +
  geom_density() +
  facet_wrap(~svd)

svd_gwa_rem %>% 
  filter(svd==1) %>% 
  ggplot(aes(x = svd_var_cos,
             y = met_z)) +
  geom_point(shape = 1,
             color = pal[2]) +
  labs(x = "variant contribution\n(squared cosine score)") +
  theme_pubr() +
  theme(legend.position = "none",
        panel.background = element_blank(),
        plot.background = element_blank(),
        text = element_text(color = pal[3], size = 32),
        axis.line = element_line(color = pal[3]),
        axis.title = element_text(color = pal[3], size = 32),
        axis.text = element_text(color = pal[3], size = 32),
        axis.ticks = element_line(color = pal[3])) 
```

#### Plot REMA GWA for tSVD component as Manhattan plot

```{r}
svd_phe_scores %>% group_by(svd) %>% arrange(-con) %>% slice_head(n=1) %>% mutate(label = ifelse(is.na(short), as.character(phe), as.character(short))) %>%
  dplyr::select(label,svd,con)

svd_gwa_rem %>% group_by(svd) %>% arrange(met_p_cor_fdr) %>% slice_head(n=1) %>% merge((var_ann %>% dplyr::select(snp,genes)), by = "snp", all.x = T)
```

```{r}
i = 5

p.svd_phe_con = svd_phe_scores %>% 
  filter(svd==i) %>% 
  arrange(-con) %>% 
  mutate(label = ifelse(is.na(short), as.character(phe), as.character(short))) %>%
  dplyr::select(label,con) %>% 
  head(n=15) %>%
  ggplot(aes(x = reorder(label, rank),
             y = con)) +
  geom_segment(
    aes(x=label, xend=label, y=0, yend=con), 
    color=pal[5], 
    size=1.3
  ) +
  geom_point(
    aes(x=label, y=con),
    color=pal[5], 
    size=5
  ) +
  coord_flip(clip = "off") +
  theme(
    legend.position="none"
  ) + 
  scale_y_continuous(expand = c(0,0)) +
  labs(x = "phenotype",
       y = "contribution score") +
  theme_pubr() +
  theme(
    legend.position = "none",
    panel.background = element_blank(),
    plot.background = element_blank(),
    panel.grid = element_line(color = pal[2]),
    panel.border = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.text = element_markdown(color = pal[3], size = 32),
    axis.text.x = element_markdown(angle = 60, size = 20, vjust = 0.5),
    text = element_text(color = pal[3], size = 32),
    axis.line = element_line(color = pal[3]),
    axis.title.x = element_markdown(color = pal[3], size = 32),
    axis.title.y = element_markdown(color = pal[3], size = 32),
    axis.ticks = element_line(color = pal[3]),
    plot.margin = margin(1, 44, 1, 0)
  )

ggsave(filename = paste("p.",tsvd_out,".svd_phe_con.i-", i, ".png", sep = ""),
       plot = p.svd_phe_con,
       device = "png",
       bg = "transparent", 
       width = 4,
       height = 4,
       units = "in")

p.svd_var_con = svd_var_scores %>% 
  filter(svd==i) %>% 
  arrange(-con) %>% 
  head(n=15) %>%
  ggplot(aes(x = paste(snp,genes,sep=":"),
             y = con)) +
  geom_segment(
    aes(x=paste(snp,genes,sep=":"), xend=paste(snp,genes,sep=":"), y=0, yend=con), 
    color=pal[5], 
    size=1.3
  ) +
  geom_point(
    aes(x=paste(snp,genes,sep=":"), y=con),
    color=pal[5], 
    size=5
  ) +
  coord_flip(clip = "off") +
  theme(
    legend.position="none"
  ) + 
  scale_y_continuous(expand = c(0,0)) +
  labs(x = "variant",
       y = "contribution score") +
  theme_pubr() +
  theme(
    legend.position = "none",
    panel.background = element_blank(),
    plot.background = element_blank(),
    panel.grid = element_line(color = pal[2]),
    panel.border = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.text = element_markdown(color = pal[3], size = 32),
    axis.text.x = element_markdown(angle = 60, size = 20, vjust = 0.5),
    text = element_text(color = pal[3], size = 32),
    axis.line = element_line(color = pal[3]),
    axis.title.x = element_markdown(color = pal[3], size = 32),
    axis.title.y = element_markdown(color = pal[3], size = 32),
    axis.ticks = element_line(color = pal[3]),
    plot.margin = margin(1, 44, 1, 0)
  )

ggsave(filename = paste("p.",tsvd_out,".svd_var_con.tall.i-", i, ".png", sep = ""),
       plot = p.svd_var_con,
       device = "png",
       bg = "transparent", 
       width = 4,
       height = 4,
       units = "in")

svd_gwa_rem_dtf = svd_gwa_rem %>%
  filter(svd == i) %>%
  arrange(chr,pos) %>%
  merge((svd_gwa_rem %>%
           filter(svd == i) %>%
           group_by(chr) %>%
           dplyr::summarize(max.pos = max(as.numeric(pos))) %>%
           mutate(pos.add = lag(cumsum(as.numeric(max.pos)), default = 0)) %>%
           dplyr::select(chr, pos.add)),
        by = "chr", all.x = T) %>%
  mutate(pos.cum = pos + pos.add) %>%
  group_by(chr) %>%
  mutate(center = mean(pos.cum)) %>%
  mutate(color = if_else(chr %% 2 == 1,
                         pal[2],
                         pal[3])) %>%
  merge((var_ann %>% dplyr::select(snp,genes)), by = "snp", all.x = T) %>%
  mutate(lower_quartile_fdr = quantile(met_p_cor_fdr, 1e-5, na.rm = TRUE)) %>%
  mutate(label = if_else(met_p_cor_fdr < lower_quartile_fdr,
                         paste(snp,genes),
                         NA_character_))

y_lim = max(-log10(svd_gwa_rem_dtf$met_p_cor_fdr[is.finite(-log10(svd_gwa_rem_dtf$met_p_cor_fdr))])) + 1
  
p.svd_gwa_rem = svd_gwa_rem_dtf %>%
  filter(!is.infinite(-log10(met_p_cor_fdr))) %>%
  ggplot(aes(x = pos.cum,
             y = -log10(met_p_cor_fdr),
             color = color)) +
  geom_point(alpha = 0.5) +
  geom_text_repel(aes(label = label), color = pal[3], box.padding = 0.5, size = 8) +
  coord_cartesian(clip = "on") +
  scale_x_continuous(
    breaks = unique(svd_gwa_rem_dtf$center), 
    labels = unique(svd_gwa_rem_dtf$chr),
    expand = c(0,0)) +
  scale_color_identity() +
  scale_y_continuous(limits = c(0,y_lim), expand = c(0,0)) +
  labs(x = "genomic position",
       y = "-log<sub>10</sub>(p)",
       caption = "contribution-weighted random-effects meta-analysis of GWA z-scores") +
  theme_minimal() +
  theme(
    legend.position = "none",
    panel.background = element_blank(),
    plot.background = element_blank(),
    panel.grid = element_line(color = pal[2]),
    panel.border = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.y = element_markdown(),
    axis.text.x = element_text(angle = 60, size = 20, vjust = 0.5),
    text = element_text(color = pal[3], size = 32),
    axis.line = element_line(color = pal[3]),
    axis.title = element_text(color = pal[3], size = 32),
    axis.text = element_text(color = pal[3], size = 32),
    axis.ticks = element_line(color = pal[3])
  )

ggsave(filename = paste("p.",tsvd_out,".svd_gwa_rem.i-", i, ".png", sep = ""),
       plot = p.svd_gwa_rem,
       device = "png",
       bg = "transparent", 
       width = 9.5,
       height = 4.5,
       units = "in")
```

z-scores instead:

```{r}
i = 1

svd_gwa_rem_dtf = svd_gwa_rem %>%
  filter(svd == i) %>%
  arrange(chr,pos) %>%
  merge((svd_gwa_rem %>%
           dplyr::filter(svd == i) %>%
           group_by(chr) %>%
           dplyr::summarize(max.pos = max(as.numeric(pos))) %>%
           mutate(pos.add = lag(cumsum(as.numeric(max.pos)), default = 0)) %>%
           dplyr::select(chr, pos.add)),
        by = "chr", all.x = T) %>%
  mutate(pos.cum = pos + pos.add) %>%
  group_by(chr) %>%
  mutate(center = mean(pos.cum)) %>%
  mutate(color = if_else(chr %% 2 == 1,
                         pal[2],
                         pal[3])) %>%
  merge((var_ann %>% dplyr::select(snp,gene_symbol)),
        by = "snp",
        all.x = T) %>%
    mutate(label = if_else(met_p_cor_fdr < 0.05,
                         paste(snp,gene_symbol),
                         NA_character_))
  
p.svd_gwa_rem = svd_gwa_rem_dtf %>%
  ggplot(aes(x = pos.cum,
             y = -log10(met_p_cor_fdr),
             color = color)) +
  geom_point(alpha = 0.5) +
  geom_text_repel(aes(label = label), color = pal[3], size = 8) +
  scale_x_continuous(
    breaks = unique(svd_gwa_rem_dtf$center), 
    labels = unique(svd_gwa_rem_dtf$chr)) +
  scale_color_identity() +
  labs(x = "genomic position",
       y = "-log<sub>10</sub>(p)") +
  theme_minimal() +
  theme(
    legend.position = "none",
    panel.background = element_blank(),
    plot.background = element_blank(),
    panel.grid = element_line(color = pal[2]),
    panel.border = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.y = element_markdown(),
    axis.text.x = element_text(angle = 60, size = 20, vjust = 0.5),
    text = element_text(color = pal[3], size = 32),
    axis.line = element_line(color = pal[3]),
    axis.title = element_text(color = pal[3], size = 32),
    axis.text = element_text(color = pal[3], size = 32),
    axis.ticks = element_line(color = pal[3])
  )

ggsave(filename = paste("p.svd_gwa_rem.i-", i, ".png", sep = ""),
       plot = p.svd_gwa_rem,
       device = "png",
       bg = "transparent", 
       width = 9.5,
       height = 4.5,
       units = "in")
```

#### Plot z-scores of top variant across REMA GWA

```{r}
i = 1

bind_cols(phe, data.frame(z=mat[which(var$snp == (svd_gwa_fem %>% 
  filter(svd==i) %>% 
  arrange(met_p_cor_fdr) %>% 
  slice_head(n=1) %>% 
  pull(snp))),])) %>%
  arrange(-abs(z)) %>%
  select(phe,short,z)

bind_cols(phe, data.frame(z=mat[which(var$snp == "26:35723572:G:A"),])) %>%
  arrange(-abs(z)) %>%
  select(phe,short,z) %>%
  View()
```

## Prepare data for modeling

We will prepare the following data for each latent component:

1.  `mod_gen`, a matrix of genotypes for `n_dog` individuals x `n_var` variants.

2.  `mod_phe`, a matrix of phenotypes for `n_dog` individuals x `n_phe` phenotypes.

3.  `mod_weights_var`, a data frame of genetic variant information, including a column `weight` for weights derived from tSVD.

4.  `mod_weights_phe`, a data frame of phenotype information, including a column `weight` for weights derived from tSVD.

5.  `mod_vargwa_cov` and `mod_phegwa_cov`, the sampling and genetic covariance matrix derived from `mat`, a matrix of GWA z-scores for `n_var` variants x `n_phe` phenotypes, and `lds`, a data frame of LD scores for `n_var` variants.

6.  `mod_grm_cov`, the sample covariance matrix derived from `grm`, a matrix of kinship values for `n_dog` individuals x `n_dog` individuals.

7.  `mod_cov`, a data frame of covariates like `age`, `sex`, and `hgt` for `n_dog` individuals.

### Select latent component to model

Here, we will perform modeling one component at a time.

```{r}
i = 1
```

### Prioritize variants and phenotypes from tSVD components

```{r}
# Select threshold for variants and phenotypes to include
top_n_var = 10000 
top_n_phe = 50 

# Calculate weights as proportion variance explained
svd_weights = sqrt((svd_res$d)^2 / sum((svd_res$d)^2))

# Pull phenotype and variant info
mod_weights_var = var
mod_weights_phe = phe

# Index component
mod_weights_var$svd = i
mod_weights_phe$svd = i

# Weight variant singular values by variance explained by components
mod_weights_var$weight = svd_weights[i] * svd_res$v[,i]

# Weight phenotype singular values by variance explained by components
mod_weights_phe$weight = svd_weights[i] * svd_res$u[,i]

# Sort by magnitude and select
mod_weights_var =  mod_weights_var %>% 
  arrange(-abs(weight)) %>% 
  slice_head(n = top_n_var)

mod_weights_phe = mod_weights_phe %>% 
  arrange(-abs(weight)) %>%
  slice_head(n = top_n_phe)

# Set indices
mod_weights_var = mod_weights_var %>%
  mutate(i_var = row_number())

mod_weights_phe = mod_weights_phe %>%
  mutate(i_phe = row_number())
```

### Prepare genotype matrix for prioritized variants

```{r}
# Select indices from `gen` that match prioritized variants
ind = match(mod_weights_var$snp, sapply(strsplit(colnames(gen), "_"), `[`, 1))

# Remove NAs in case some SNPs are not found
ind = ind[!is.na(ind)]

# Filter genotype data by prioritized variants
mod_gen = gen[, ind]

# Set dog names
rownames(mod_gen) = sapply(strsplit(rownames(mod_gen), "_"), `[`, 1)

# Fill genotypes with 0 if NA
mod_gen[is.na(mod_gen)] = 0
```

### Prepare covariate data

```{r}
# Pull sex, height, weight, and age from dog table
mod_cov = dog %>%
  select(dog,sex,hgt=height_filled,wgt=weight_filled,age=age_group) %>%
  merge((data.frame(dog = rownames(mod_gen),
                    i_dog = 1:length(rownames(mod_gen)))),
        by = "dog") %>%
  arrange(i_dog)
```

### Prepare phenotype matrix for prioritized phenotypes

```{r}
# Pull prioritized items from questions table
mod_phe = 
  ans %>%
  filter(dog %in% rownames(mod_gen)) %>%
  merge((mod_weights_phe %>% select(item,phe,weight)),
        by.x = "question",
        by.y = "item") %>%
  select(dog,question,answer) %>%
  mutate(answer = as.numeric(answer)) %>%
  complete(dog, question) %>%
  group_by(question) %>%
  mutate(mean_answer = mean(answer, na.rm = TRUE)) %>%
  mutate(answer = if_else(is.na(answer),
                          mean_answer,
                          answer)) %>%
  select(-mean_answer) %>%
  pivot_wider(id_cols = "dog",
              names_from = "question",
              values_from = "answer") %>%
  arrange(match(dog, rownames(mod_gen)))
```

### Unify dogs across genotype, phenotype, and covariate data

```{r}
# Remove dogs missing covariate data
mod_gen = mod_gen[rownames(mod_gen) %in% mod_cov$dog,]

# Remove dogs missing phenotype data
mod_gen = mod_gen[rownames(mod_gen) %in% mod_phe$dog,]

# Remove dogs not in mod_gen from mod_phe and mod_cov
mod_phe = mod_phe %>% filter(dog %in% rownames(mod_gen))
mod_cov = mod_cov %>% filter(dog %in% rownames(mod_gen))
```

### Store info and re-name variables

```{r}
# Save coded allele variant ID to mod_weights_var
mod_weights_var$coded_allele = sapply(strsplit(colnames(mod_gen), "_"), `[`, 2)

# Re-name cols as 'var' 1:i_var in mod_gen
colnames(mod_gen) = paste("var", mod_weights_var$i_var, sep = "")

# Re-name rows as 'dog' 1:i_dog in mod_gen
rownames(mod_gen) = paste("dog", mod_cov$i_dog, sep = "")

# Drop dog from mod_phe
mod_phe = mod_phe %>% select(-dog)

# Set mod_phe as matrix
mod_phe = as.matrix(mod_phe)

# Re-name rows as 'dog' 1:i_dog in mod_phe
rownames(mod_phe) = paste("dog", mod_cov$i_dog, sep = "")
```

### Calculate genetic covariance matrix adjusted by LD score

```{r}
# Vectorized function to calculate modified GWAS covariance
vectorized_cov = function(mat, lds) {
  scaled_mat = mat * sqrt(lds$L2)
  return(scaled_mat %*% t(scaled_mat))
}

# Subset GWA matrix
mod_gwa = mat[,(which(phe$phe %in% mod_weights_phe$phe))]

# Subset LD scores
mod_lds = lds %>% filter(SNP %in% mod_weights_var$snp)

# Generate covariance matrix
cov_mat = vectorized_cov(t(mod_gwa), mod_lds)

# Add row and column names
rownames(cov_mat) = mod_weights_phe$phe
colnames(cov_mat) = mod_weights_phe$phe

# Hierarchical clustering
cov_mat = cov_mat[hclust(dist(cov_mat))$order,hclust(dist(cov_mat))$order]

# Convert covariance to correlation matrix
cor_mat = cov2cor(cov_mat)

# Convert to data frame and set factors
cor_mat_dt = as.data.frame(as.table(cor_mat))
cor_mat_dt$Var1 = factor(cor_mat_dt$Var1, levels = rownames(cor_mat))
cor_mat_dt$Var2 = factor(cor_mat_dt$Var2, levels = rev(rownames(cor_mat)))
```

### MOVE! Plot genetic correlations of phenotypes in latent component

move to contribute score + meta GWA plotting part

```{r}
p.cov = cor_mat_dt %>%
  rename(`genetic correlation` = Freq) %>%
  ggplot(aes(x = str_wrap(Var1, width=40), 
             y = str_wrap(Var2, width=40))) +
  geom_tile(aes(fill = `genetic correlation`)) +
  scale_size_continuous(range = c(1, 10)) +
  scale_fill_gradient(low = pal[4], high = pal[2]) +
  theme_pubr() +
  theme(axis.title = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_text(color = pal[3], size = 4),
        panel.background = element_blank(),
        plot.background = element_blank(),
        text = element_text(color = pal[3]),
        axis.ticks = element_line(color = pal[3]),
        plot.margin = margin(1, 1, 1, 1, "cm")) 
ggsave(filename = paste("p.gen-cov.component-", i, ".pdf", sep = ""),
       plot = p.cov,
       device = "pdf",
       units = "in",
       height = 8.5,
       width = 5)
```

## Modeling latent components in individuals

### Confirmatory factor analysis

```{r}
# Scale each phenotype value and genotype value by tSVD weights
scaled_phe = sweep(mod_phe, 2, mod_weights_phe$weight, "*")
scaled_var = sweep(mod_gen, 2, mod_weights_var$weight, "*")
combined_data = data.frame(scaled_phe, scaled_var)

# SEM model formula
sem_formula = paste("# Latent variable definition\nlatent_var =~ ",
                    paste(colnames(mod_gen), collapse = " + "),
                    " + ",
                    paste(colnames(mod_phe), collapse = " + "),
                    sep = "")

# Fit the SEM model
fit = sem(sem_formula, data = combined_data)

# Display the summary
summary(fit)
```

```{r}
for(i in 1:n_svd) {
  # Select indices from `gen` that match prioritized variants
  ind = match(prior_var[prior_var$svd == i,]$snp, 
              sapply(strsplit(colnames(gen), "_"), `[`, 1))
  
  # Remove NAs in case some SNPs are not found
  ind = ind[!is.na(ind)]

  # Filter genotype data by prioritized variants
  selected_gen = gen[, ind]

  # Combine selected genotypes, kinship, and selected phenotypes
  combined_data = data.frame(selected_gen, grm$kinship, selected_phe)
}
```

### Define formula and run SEM using lavaan package

```{r}
i = 1



sem_formula = paste(,
                    sep = "\n")

sem_formula = function(var_names, phe_names, covariate_names){
  # Measurement models for weighted latent variables
  latent_var = paste(paste("W_var*", var_names, collapse = " + "), " =~ f1")
  latent_phe = paste(paste("W_phe*", phe_names, collapse = " + "), " =~ f2")

  # Regression and Covariance
  regression_phe = "f2 ~ c*theta*K*theta + c1*f1"
  covariance = "f1 ~~ theta*K*theta"
  
  # Covariates
  covariates_var = paste(paste("c_", covariate_names, "*", covariate_names, collapse = " + "), " ~ f1")
  covariates_phe = paste(paste("c_", covariate_names, "*", covariate_names, collapse = " + "), " ~ f2")

  # Combine all parts
  sem_formula = paste(latent_var, latent_phe, regression_phe, covariance, covariates_var, covariates_phe, sep = "\n")
  
  return(sem_formula)
}

# Define names based on your matrices and data frames
var_names = colnames(sem_gen)
phe_names = colnames(sem_phe)
covariate_names = colnames(sem_cov)

# Generate SEM formula
sem_formula = generate_sem_formula(var_names, phe_names, covariate_names)

# Fit the SEM model (assuming `your_data_frame` contains all necessary columns)
library(lavaan)
fit = sem(sem_formula, data=your_data_frame, fixed.x=FALSE, estimator="WLS")
```

# Summary Statistics

```{r}
# genotype matrix n_dog dogs x n_var variants
nrow(gen)
ncol(gen)

# kinship matrix n_dog dogs x n_dog dogs
nrow(grm$kinship)
ncol(grm$kinship)

# tSVD d vector n_svd components
length(svd_res$d)

# tSVD u matrix n_phe phenotypes x n_svd components
nrow(svd_res$u)
ncol(svd_res$u)

# tSVD v matrix n_var variants x n_svd components
nrow(svd_res$v)
ncol(svd_res$v)

# original GWA matrix of z-scores n_var variants x n_phe phenotypes
nrow(mat)
ncol(mat)
```

# Withdrawn Code

The following code needs refactoring or repair:

### Fixed-effects meta-analysis of GWA z-scores (FEMA)

In this analysis, we execute a fixed-effects meta-analysis using genome-wide association z-scores. Each phenotype column in the GWA z-score matrix (variant x phenotype) is element-wise multiplied by its corresponding squared cosine score vector. The same operation is performed for each variant row using the variant's squared cosine score. The sum of each row post these multiplications yields the meta z-score for each variant. Subsequently, the meta p-values are calculated based on the absolute meta z-scores. These meta p-values are then corrected for multiple testing using the Benjamini & Hochberg false discovery rate (FDR) method. This workflow allows for incorporation of each tSVD component's influence in the meta-analysis.

```{r}
svd_gwa_fem = data.frame()

for (i in 1:n_svd) {
  # Calculate meta z-score for all variants for component i
  met_z = rowSums(sweep(sweep(mat[, slice_phe], 2, cos_phe[slice_phe, i], "*"), 1, cos_var[, i], "*"))

  # Calculate meta p-value for all variants for component i
  met_p = 2 * (1 - pnorm(abs(met_z)))
  
  tmp_df = data.frame(
    svd = rep(i, length(met_z)),
    chr = var$chr,
    pos = var$pos,
    ref = var$ref,
    alt = var$alt,
    snp = var$snp,
    svd_var_con = svd_res$v[, i],
    met_z = met_z,
    met_p = met_p
  )
  
  svd_gwa_fem = rbind(svd_gwa_fem, tmp_df)
}

svd_gwa_fem = svd_gwa_fem %>%
  group_by(svd) %>%
  mutate(met_p_cor_fdr = p.adjust(met_p, method = "fdr"))
```

#### Plot FEMA GWA for tSVD component as Manhattan plot

```{r}
i = 12

svd_gwa_fem_dtf = svd_gwa_fem %>%
  filter(svd == i) %>%
  arrange(chr,pos) %>%
  merge((svd_gwa_fem %>%
           filter(svd == i) %>%
           group_by(chr) %>%
           summarize(max.pos = max(as.numeric(pos))) %>%
           mutate(pos.add = lag(cumsum(as.numeric(max.pos)), default = 0)) %>%
           select(chr, pos.add)),
        by = "chr", all.x = T) %>%
  mutate(pos.cum = pos + pos.add) %>%
  group_by(chr) %>%
  mutate(center = mean(pos.cum)) %>%
  mutate(color = if_else(chr %% 2 == 1,
                         pal[2],
                         pal[3])) %>%
  mutate(label = if_else(met_p_cor_fdr < 0.05,
                         snp,
                         NA_character_))
  
p.svd_gwa_fem = svd_gwa_fem_dtf %>%
  ggplot(aes(x = pos.cum,
             y = -log10(met_p_cor_fdr),
             color = color)) +
  geom_point(alpha = 0.5) +
  geom_text_repel(aes(label = label), color = pal[3], size = 8) +
  scale_x_continuous(
    breaks = unique(svd_gwa_fem_dtf$center), 
    labels = unique(svd_gwa_fem_dtf$chr)) +
  scale_color_identity() +
  labs(x = "genomic position",
       y = "-log<sub>10</sub>(p)") +
  theme_minimal() +
  theme(
    legend.position = "none",
    panel.background = element_blank(),
    plot.background = element_blank(),
    panel.grid = element_line(color = pal[2]),
    panel.border = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.y = element_markdown(),
    axis.text.x = element_text(angle = 60, size = 20, vjust = 0.5),
    text = element_text(color = pal[3], size = 32),
    axis.line = element_line(color = pal[3]),
    axis.title = element_text(color = pal[3], size = 32),
    axis.text = element_text(color = pal[3], size = 32),
    axis.ticks = element_line(color = pal[3])
  )

ggsave(filename = paste("p.svd_gwa_fem.i-", i, ".png", sep = ""),
       plot = p.svd_gwa_fem,
       device = "png",
       bg = "transparent", 
       width = 9.5,
       height = 4.5,
       units = "in")
```

#### Plot z-scores of top variant across FEMA GWA

```{r}
i = 1

bind_cols(phe, data.frame(z=mat[which(var$snp == (svd_gwa_fem %>% 
  filter(svd==i) %>% 
  arrange(met_p_cor_fdr) %>% 
  slice_head(n=1) %>% 
  pull(snp))),])) %>%
  arrange(-abs(z)) %>%
  select(phe,short,z)

bind_cols(phe, data.frame(z=mat[which(var$snp == "26:35723572:G:A"),])) %>%
  arrange(-abs(z)) %>%
  select(phe,short,z) %>%
  View()
```

# Discarded Snippets

The follow snippets may be handy later but don't fit in the workflow:

```{r}
# Select phenotypes of highest contribution
  slice_phe = which(phe$phe %in% (svd_phe_scores %>%
                                    filter(svd==i) %>%
                                    filter(abs(fac) >= quantile(abs(fac), 0.75),
                                           abs(con) >= quantile(abs(con), 0.75),
                                           abs(cos) >= quantile(abs(cos), 0.75)) %>%
                                    pull(phe)))

  
```

### Generate dog covariance matrix

```{r}
mod_grm_cov = smooth(grm$kinship[rownames(grm$kinship) %in% mod_cov$dog, colnames(grm$kinship) %in% mod_cov$dog])
```

```{r}
#mod_gwa = mat[(which(var$snp %in% mod_weights_var$snp)),(which(phe$phe %in% mod_weights_phe$phe))]

```
